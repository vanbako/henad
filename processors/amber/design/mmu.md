# Amber MMU Architecture (proposal)

This note outlines a minimal but defensively-implemented memory-management unit for the Amber core. It targets 24-bit BAU (word-granular) accesses, 48-bit virtual and physical addresses, and integrates with Amber's CHERI capability checks.

## Goals & Threat Model

- Maintain CHERI spatial safety while adding demand-paged virtual memory.
- Support user/kernel isolation, shared pages, and per-process address spaces.
- Prevent user code from widening access through translation; capabilities remain the authority on bounds and permissions.
- Keep the hardware walker simple enough for FPGA prototypes while allowing future extension (larger TLBs, superpages).

The MMU assumes that capability checks already limit the virtual address (`VA`) that reaches the MMU. The MMU must ensure that the resulting physical address (`PA`) respects page permissions and port routing so that capabilities cannot be used to cross privilege or fabric domains via aliasing.

## Address Formats

### Virtual address

Amber retains the 48-bit virtual address format hinted in the CHERI docs. With a 4 Ki-word page size (4096 × 24-bit words → 12 KiB), the low 12 bits form the page offset.

```
|47 ............... 12|11 ........ 0|
|      VPN[35:0]      |  page offs  |
```

- Offset selects one of 4096 words (12-bit addressing).
- `VPN` is split across three levels of page tables (12 bits per level).
- Virtual addresses are generated by adding a signed offset to a capability cursor; the MMU never manipulates cursor or bounds directly.

### Physical address

Physical memory keeps the planned split: a 6-bit port ID naming a fabric endpoint plus a 42-bit local address. The page offset is copied verbatim from the VA.

```
|47 ... 42|41 .............. 12|11 ........ 0|
| port ID |   PPN[29:0]       |  page offs  |
```

- `PPN` (page number) gives 30 bits → 4 Gi-word (≈12 GiB) per port.
- Combined with 6-bit port ID, the MMU can address up to 64 memory/IO regions.
- Fabric policies can reject accesses to ports that are not permitted for the current privilege level.

## Page Table Structure

To map 36 bits of VPN, the MMU uses a 3-level tree (L2, L1, L0), each indexed by 12 bits:

```
VPN[35:24] → Level 2 (root)
VPN[23:12] → Level 1
VPN[11:0]  → Level 0 (leaf containing PTE)
```

Each page table is an array of 4096 entries. Tables are naturally aligned to 12 KiB boundaries so that an index selects the correct 24-bit word pair.

### PTE layout (48 bits / 2 × 24-bit words)

```
|47|46|45 .. 40|39 .......... 10|9|8|7|6|5|4|3|2|1|0|
|V |G |port ID |       PPN      |NX|NW|NR|NS|NL|NU|SW|SW|SW|SW|
```

- `V`: valid entry.
- `G`: global (ignores ASID match).
- `port ID`: six bits selecting the target fabric port.
- `PPN`: 30-bit physical page number (top of the resolved address).
- `NX/NW/NR`: deny execute/write/read (set = deny). Hardware computes allow = `~N*`.
- `NS`: supervisor-only page (kernel).
- `NL`: linear (device/uncached) hint; forwarded to cache/memory fabric.
- `NU`: user access allowed when clear; if set, only kernel-mode may access.
- `SW[3:0]`: software-defined bits. Hardware ignores them but exposes accessed/dirty information through the TLB probe CSRs so firmware can mirror that state lazily.

PTEs occupy two consecutive 24-bit words. Software updates must be 48-bit coherent, typically by writing both words under a CHERI-validated capability.

### Page Table Root & ASID

A dedicated CSR window programs the walk engine:

- `MMU_ROOT_LO/MMU_ROOT_HI`: 48-bit physical base of the level-2 table; must be aligned to 12 Ki-word boundaries. Writes are kernel-only.
- `MMU_ASID`: bits[23:8] hold a 16-bit address-space identifier. Bit0 mirrors the current privilege mode for diagnostics, bit1 marks a shared address space (e.g. kernel global mappings), and the remaining bits are reserved.

The root pointer is written as a physical address because the walker operates after CHERI translation. Kernel firmware derives the physical value by inspecting its page-table capability and then storing it through the CSR interface.

## Translation Flow

1. EX computes effective virtual address and capability. CHERI checks run in MA using virtual addressing.
2. Once CHERI passes, MA forwards the VA, access type (load/store/exec), privilege (user/kernel), and hints (`NL`) to the MMU.
3. MMU consults TLB. On hit, it returns the PA, port ID, and page attributes to MA/MO for cache/tag decisions.
4. On miss, a hardware walker performs the 3-level translation:
   - Reads the level table entry through the data cache using kernel-only physical accesses.
   - Each read is authorised by the dedicated walker capability window defined by `MMU_WALK_BASE/MMU_WALK_LEN`.
   - Any invalid entry, permission denial, or access to a non-existent fabric port raises a page fault trap.
5. Walker installs the resolved translation into the TLB (unless `NL` or other hints forbid caching).
6. On success, translation completes, caches are accessed with the resolved PA, and port ID informs fabric routing.

## TLB Design

- Separate ITLB and DTLB to match the existing I/D split. Each has 32 fully-associative entries initially.
- Entries are tagged by `VPN[35:12]` + `ASID`.
- ITLB ignore writes (`NR/NW` bits) but enforce execute bits.
- DTLB tracks dirty state (`D`) and accessed state (`A`) in a small side array updated on first use. The bits surface through `MMU_TLBMETA` and can be cleared by invalidating the entry; hardware does not write them back into PTE storage.
- TLB entries cache: `PA base`, `port ID`, permission bits, `NL` hint, `NS/NU` attributes.
- TLB flush instructions:
  - `TLBINV_ALL`: flush both TLBs.
  - `TLBINV_ASID`: flush matching ASID.
  - `TLBINV_PAGE`: flush a single VA.
- These flush operations are triggered via new privileged `TLBOP` instructions or CSR writes.

## Protection & Fault Handling

The MMU reports page faults through new trap causes:

- `MMU_VINV` (invalid entry) when any level has `V=0`.
- `MMU_PERM` when the page denies the requested access (`NX/NW/NR`, `NS/NU` mismatches).
- `MMU_PORT` when the resolved port is not provisioned or not allowed in current mode.
- `MMU_ALIGN` when the VA offset violates capability alignment but passes CHERI.
- `MMU_PTAB` when the walker detects malformed tables (e.g., misaligned pointer, recursive mapping loops).

Kernel trap handler receives `VA`, access type, and the CL index (CRs) through auxiliary trap info registers. Software may install demand pages, adjust permissions, or terminate the offending process.

## Interaction with CHERI

- Capabilities still gate all memory access; the MMU cannot be used to widen a capability's range because translation is done after the MA stage's CHERI checks.
- Page permissions are an additional filter. The effective permissions are: `Capability perms` AND `Page perms`.
- For user pages, `NU` must be clear; kernel-only data uses `NU=1`.
- Capability loads/stores (`CLD/CST`) require both page `NR/NW` clear (allow) and capability permissions (LC/SC) satisfied.
- PCC fetch validation occurs before translation; ITLB rejects pages lacking execute rights and raises `EXEC_PERM`.

## Walk Engine Implementation Notes

- Walker runs in the MA stage microcode when a miss occurs; pipeline is stalled until completion.
- Each level fetch uses the hardware walker window described by `MMU_WALK_BASE/MMU_WALK_LEN`. The walker increments by two words per PTE to stay 48-bit aligned.
- Tables stored in normal memory and are cached. `NL` hint in entries allows mapping device memory that bypasses caches.
- For safety, the walker performs bounds checking on each table pointer to ensure it lies within the configured window before issuing memory reads.

## CSR Window

Amber reserves CSR indices 0x100–0x111 for MMU control. Each entry is a 24-bit word; 48-bit values are split into LO/HI pairs consistent with the rest of the architecture.

| CSR | Description |
|-----|-------------|
| `0x100 MMU_CFG` | bit0 `EN`, bit1 `EN_ITLB`, bit2 `EN_DTLB`, bits[9:4] walker timeout (cycles), bits[23:10] reserved. Only kernels may write; user reads return zero except for `EN` mirror. |
| `0x101 MMU_STATUS` | Sticky fault summary in bits[3:0] (`VINV`, `PERM`, `PORT`, `PTAB`), bit4 walker busy, bits[23:8] last faulting ASID. Writing 1s clears set bits. |
| `0x102/0x103 MMU_ROOT_LO/HI` | Physical base of the level-2 table (48 bits). Must be aligned to 12 Ki-word boundaries. |
| `0x104 MMU_ASID` | Bits[23:8] ASID, bit1 shared-space flag, bit0 mode mirror, rest reserved. |
| `0x105/0x106 MMU_WALK_BASE_LO/HI` | Base of walker capability window (48 bits). |
| `0x107/0x108 MMU_WALK_LEN_LO/HI` | Length of walker capability window (48 bits). Perms are implied: read-only fetches allowed, writes blocked. |
| `0x109/0x10A MMU_PORTMASK0/1` | 48-bit bitmap of allowable port IDs (bits 0–47). |
| `0x10B MMU_PORTMASK2` | Bits 63–48 of the port mask (upper eight bits used; others reserved). |
| `0x10C/0x10D MMU_FAULT_VA_LO/HI` | Captures the last faulting virtual address. |
| `0x10E MMU_TLBIDX` | Bits[4:0] select entry, bit5 selects ITLB (=0) vs DTLB (=1). Writes freeze the entry for inspection. |
| `0x10F MMU_TLBDATA_LO` | Low 24 bits of the selected entry: bits[5:0] permission mask (R/W/X/NU/NS/NL), bits[11:6] port ID, bits[23:12] low PPN. Writable only when `MMU_TLBMETA.valid` is clear. |
| `0x110 MMU_TLBDATA_HI` | High 24 bits of the selected entry: bits[23:0] high PPN. |
| `0x111 MMU_TLBMETA` | Metadata view: bit0 valid, bit1 global, bit2 NU, bit3 NS, bit4 accessed, bit5 dirty, bits[15:8] ASID tag. |

Entries beyond 0x10F (the TLB data/meta registers) extend the window but remain contiguous for programmer convenience. Firmware is expected to mask user-mode reads so unprivileged code observes zeros for port masks, walker configuration, and fault registers.

When probing a TLB entry, software reconstructs the 48-bit physical base as `{MMU_TLBDATA_HI, MMU_TLBDATA_LO[23:12]}` and obtains the cached permissions/port from `MMU_TLBDATA_LO[11:0]`. `MMU_TLBMETA` provides the live accessed/dirty bits that the operating system can later fold back into the PTE when it evicts or demotes an entry.

## Software Model

1. Kernel places page tables inside the region covered by the walker capability (`MMU_WALK_BASE/MMU_WALK_LEN`).
2. Per-process initialisation fills PTEs with the desired `port ID`, `PPN`, and permission bits while ensuring the port mask allows the target fabric segment.
3. Kernel programs `MMU_PORTMASK*`, `MMU_ROOT_*`, and `MMU_ASID`, then sets `MMU_CFG.EN`, `EN_ITLB`, and `EN_DTLB` before entering user mode.
4. Context switches update the ASID, optionally the root pointer and port masks, and execute the appropriate `TLBINV_*` operation to flush stale translations.
5. Page faults trap into kernel; the handler inspects `MMU_STATUS` and `MMU_FAULT_VA_*`, services the fault, mirrors accessed/dirty bits from `MMU_TLBMETA` into software-maintained PTE fields, invalidates the TLB entry, and resumes.

## Implementation Checklist

- Reserve CSR indices 0x100–0x111 in `csr.md`, including user-visible masking rules.
- Add assembler support and RTL decode for `TLBINV_ALL`, `TLBINV_ASID`, and `TLBINV_PAGE`.
- Implement `MMU_CFG` gating in the MA/MO pipeline and stall logic for walker operations.
- Teach the trap handler to read `MMU_STATUS`/`MMU_FAULT_VA_*` and report port violations distinctly.
- Provide a kernel helper to program walker capability and port masks during boot.

## Future Extensions

- **Superpages**: reuse reserved PTE bits to encode 2 MiB / 1 GiB equivalents by collapsing lower levels.
- **Per-port policy**: integrate with fabric firewall so `port ID` resolves to memory attributes.
- **Speculative walker**: prefetch next-level PTEs using small caches.
- **Capability tagging**: extend PTE with CHERI metadata to speed up permission checks.
